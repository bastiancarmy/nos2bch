const q = Object.create; const O = Object.defineProperty; const U = Object.getOwnPropertyDescriptor; const z = Object.getOwnPropertyNames; const Z = Object.getPrototypeOf, G = Object.prototype.hasOwnProperty; const H = (t, a) => () => (a || t((a = { exports: {} }).exports, a), a.exports); const V = (t, a, o, b) => { if (a && typeof a === 'object' || typeof a === 'function') for (const l of z(a))!G.call(t, l) && l !== o && O(t, l, { get: () => a[l], enumerable: !(b = U(a, l)) || b.enumerable }); return t }; const K = (t, a, o) => (o = t != null ? q(Z(t)) : {}, V(a || !t || !t.__esModule ? O(o, 'default', { value: t, enumerable: !0 }) : o, t)); const $ = H((T, _) => { (function(t, a) { if (typeof define === 'function' && define.amd)define('webextension-polyfill', ['module'], a); else if (typeof T < 'u')a(_); else { const o = { exports: {} }; a(o), t.browser = o.exports } })(typeof globalThis < 'u' ? globalThis : typeof self < 'u' ? self : T, function(t) { 'use strict'; if (typeof browser > 'u' || Object.getPrototypeOf(browser) !== Object.prototype) { const a = 'The message port closed before a response was received.', o = 'Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)', b = l => { const k = { alarms: { clear: { minArgs: 0, maxArgs: 1 }, clearAll: { minArgs: 0, maxArgs: 0 }, get: { minArgs: 0, maxArgs: 1 }, getAll: { minArgs: 0, maxArgs: 0 } }, bookmarks: { create: { minArgs: 1, maxArgs: 1 }, get: { minArgs: 1, maxArgs: 1 }, getChildren: { minArgs: 1, maxArgs: 1 }, getRecent: { minArgs: 1, maxArgs: 1 }, getSubTree: { minArgs: 1, maxArgs: 1 }, getTree: { minArgs: 0, maxArgs: 0 }, move: { minArgs: 2, maxArgs: 2 }, remove: { minArgs: 1, maxArgs: 1 }, removeTree: { minArgs: 1, maxArgs: 1 }, search: { minArgs: 1, maxArgs: 1 }, update: { minArgs: 2, maxArgs: 2 } }, browserAction: { disable: { minArgs: 0, maxArgs: 1, fallbackToNoCallback: !0 }, enable: { minArgs: 0, maxArgs: 1, fallbackToNoCallback: !0 }, getBadgeBackgroundColor: { minArgs: 1, maxArgs: 1 }, getBadgeText: { minArgs: 1, maxArgs: 1 }, getPopup: { minArgs: 1, maxArgs: 1 }, getTitle: { minArgs: 1, maxArgs: 1 }, openPopup: { minArgs: 0, maxArgs: 0 }, setBadgeBackgroundColor: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 }, setBadgeText: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 }, setIcon: { minArgs: 1, maxArgs: 1 }, setPopup: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 }, setTitle: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 } }, browsingData: { remove: { minArgs: 2, maxArgs: 2 }, removeCache: { minArgs: 1, maxArgs: 1 }, removeCookies: { minArgs: 1, maxArgs: 1 }, removeDownloads: { minArgs: 1, maxArgs: 1 }, removeFormData: { minArgs: 1, maxArgs: 1 }, removeHistory: { minArgs: 1, maxArgs: 1 }, removeLocalStorage: { minArgs: 1, maxArgs: 1 }, removePasswords: { minArgs: 1, maxArgs: 1 }, removePluginData: { minArgs: 1, maxArgs: 1 }, settings: { minArgs: 0, maxArgs: 0 } }, commands: { getAll: { minArgs: 0, maxArgs: 0 } }, contextMenus: { remove: { minArgs: 1, maxArgs: 1 }, removeAll: { minArgs: 0, maxArgs: 0 }, update: { minArgs: 2, maxArgs: 2 } }, cookies: { get: { minArgs: 1, maxArgs: 1 }, getAll: { minArgs: 1, maxArgs: 1 }, getAllCookieStores: { minArgs: 0, maxArgs: 0 }, remove: { minArgs: 1, maxArgs: 1 }, set: { minArgs: 1, maxArgs: 1 } }, devtools: { inspectedWindow: { eval: { minArgs: 1, maxArgs: 2, singleCallbackArg: !1 } }, panels: { create: { minArgs: 3, maxArgs: 3, singleCallbackArg: !0 }, elements: { createSidebarPane: { minArgs: 1, maxArgs: 1 } } } }, downloads: { cancel: { minArgs: 1, maxArgs: 1 }, download: { minArgs: 1, maxArgs: 1 }, erase: { minArgs: 1, maxArgs: 1 }, getFileIcon: { minArgs: 1, maxArgs: 2 }, open: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 }, pause: { minArgs: 1, maxArgs: 1 }, removeFile: { minArgs: 1, maxArgs: 1 }, resume: { minArgs: 1, maxArgs: 1 }, search: { minArgs: 1, maxArgs: 1 }, show: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 } }, extension: { isAllowedFileSchemeAccess: { minArgs: 0, maxArgs: 0 }, isAllowedIncognitoAccess: { minArgs: 0, maxArgs: 0 } }, history: { addUrl: { minArgs: 1, maxArgs: 1 }, deleteAll: { minArgs: 0, maxArgs: 0 }, deleteRange: { minArgs: 1, maxArgs: 1 }, deleteUrl: { minArgs: 1, maxArgs: 1 }, getVisits: { minArgs: 1, maxArgs: 1 }, search: { minArgs: 1, maxArgs: 1 } }, i18n: { detectLanguage: { minArgs: 1, maxArgs: 1 }, getAcceptLanguages: { minArgs: 0, maxArgs: 0 } }, identity: { launchWebAuthFlow: { minArgs: 1, maxArgs: 1 } }, idle: { queryState: { minArgs: 1, maxArgs: 1 } }, management: { get: { minArgs: 1, maxArgs: 1 }, getAll: { minArgs: 0, maxArgs: 0 }, getSelf: { minArgs: 0, maxArgs: 0 }, setEnabled: { minArgs: 2, maxArgs: 2 }, uninstallSelf: { minArgs: 0, maxArgs: 1 } }, notifications: { clear: { minArgs: 1, maxArgs: 1 }, create: { minArgs: 1, maxArgs: 2 }, getAll: { minArgs: 0, maxArgs: 0 }, getPermissionLevel: { minArgs: 0, maxArgs: 0 }, update: { minArgs: 2, maxArgs: 2 } }, pageAction: { getPopup: { minArgs: 1, maxArgs: 1 }, getTitle: { minArgs: 1, maxArgs: 1 }, hide: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 }, setIcon: { minArgs: 1, maxArgs: 1 }, setPopup: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 }, setTitle: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 }, show: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 } }, permissions: { contains: { minArgs: 1, maxArgs: 1 }, getAll: { minArgs: 0, maxArgs: 0 }, remove: { minArgs: 1, maxArgs: 1 }, request: { minArgs: 1, maxArgs: 1 } }, runtime: { getBackgroundPage: { minArgs: 0, maxArgs: 0 }, getPlatformInfo: { minArgs: 0, maxArgs: 0 }, openOptionsPage: { minArgs: 0, maxArgs: 0 }, requestUpdateCheck: { minArgs: 0, maxArgs: 0 }, sendMessage: { minArgs: 1, maxArgs: 3 }, sendNativeMessage: { minArgs: 2, maxArgs: 2 }, setUninstallURL: { minArgs: 1, maxArgs: 1 } }, sessions: { getDevices: { minArgs: 0, maxArgs: 1 }, getRecentlyClosed: { minArgs: 0, maxArgs: 1 }, restore: { minArgs: 0, maxArgs: 1 } }, storage: { local: { clear: { minArgs: 0, maxArgs: 0 }, get: { minArgs: 0, maxArgs: 1 }, getBytesInUse: { minArgs: 0, maxArgs: 1 }, remove: { minArgs: 1, maxArgs: 1 }, set: { minArgs: 1, maxArgs: 1 } }, managed: { get: { minArgs: 0, maxArgs: 1 }, getBytesInUse: { minArgs: 0, maxArgs: 1 } }, sync: { clear: { minArgs: 0, maxArgs: 0 }, get: { minArgs: 0, maxArgs: 1 }, getBytesInUse: { minArgs: 0, maxArgs: 1 }, remove: { minArgs: 1, maxArgs: 1 }, set: { minArgs: 1, maxArgs: 1 } } }, tabs: { captureVisibleTab: { minArgs: 0, maxArgs: 2 }, create: { minArgs: 1, maxArgs: 1 }, detectLanguage: { minArgs: 0, maxArgs: 1 }, discard: { minArgs: 0, maxArgs: 1 }, duplicate: { minArgs: 1, maxArgs: 1 }, executeScript: { minArgs: 1, maxArgs: 2 }, get: { minArgs: 1, maxArgs: 1 }, getCurrent: { minArgs: 0, maxArgs: 0 }, getZoom: { minArgs: 0, maxArgs: 1 }, getZoomSettings: { minArgs: 0, maxArgs: 1 }, goBack: { minArgs: 0, maxArgs: 1 }, goForward: { minArgs: 0, maxArgs: 1 }, highlight: { minArgs: 1, maxArgs: 1 }, insertCSS: { minArgs: 1, maxArgs: 2 }, move: { minArgs: 2, maxArgs: 2 }, query: { minArgs: 1, maxArgs: 1 }, reload: { minArgs: 0, maxArgs: 2 }, remove: { minArgs: 1, maxArgs: 1 }, removeCSS: { minArgs: 1, maxArgs: 2 }, sendMessage: { minArgs: 2, maxArgs: 3 }, setZoom: { minArgs: 1, maxArgs: 2 }, setZoomSettings: { minArgs: 1, maxArgs: 2 }, update: { minArgs: 1, maxArgs: 2 } }, topSites: { get: { minArgs: 0, maxArgs: 0 } }, webNavigation: { getAllFrames: { minArgs: 1, maxArgs: 1 }, getFrame: { minArgs: 1, maxArgs: 1 } }, webRequest: { handlerBehaviorChanged: { minArgs: 0, maxArgs: 0 } }, windows: { create: { minArgs: 0, maxArgs: 1 }, get: { minArgs: 1, maxArgs: 2 }, getAll: { minArgs: 0, maxArgs: 1 }, getCurrent: { minArgs: 0, maxArgs: 1 }, getLastFocused: { minArgs: 0, maxArgs: 1 }, remove: { minArgs: 1, maxArgs: 1 }, update: { minArgs: 2, maxArgs: 2 } } }; if (Object.keys(k).length === 0) throw new Error('api-metadata.json has not been included in browser-polyfill'); class S extends WeakMap {constructor(r, n = void 0) { super(n), this.createItem = r }get(r) { return this.has(r) || this.set(r, this.createItem(r)), super.get(r) }} let F = e => e && typeof e === 'object' && typeof e.then === 'function', M = (e, r) => (...n) => { l.runtime.lastError ? e.reject(new Error(l.runtime.lastError.message)) : r.singleCallbackArg || n.length <= 1 && r.singleCallbackArg !== !1 ? e.resolve(n[0]) : e.resolve(n) }, h = e => e == 1 ? 'argument' : 'arguments', B = (e, r) => function(g, ...m) { if (m.length < r.minArgs) throw new Error(`Expected at least ${r.minArgs} ${h(r.minArgs)} for ${e}(), got ${m.length}`); if (m.length > r.maxArgs) throw new Error(`Expected at most ${r.maxArgs} ${h(r.maxArgs)} for ${e}(), got ${m.length}`); return new Promise((A, c) => { if (r.fallbackToNoCallback) try { g[e](...m, M({ resolve: A, reject: c }, r)) } catch (s) { console.warn(`${e} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `, s), g[e](...m), r.fallbackToNoCallback = !1, r.noCallback = !0, A() } else r.noCallback ? (g[e](...m), A()) : g[e](...m, M({ resolve: A, reject: c }, r)) }) }, R = (e, r, n) => new Proxy(r, { apply(g, m, A) { return n.call(m, e, ...A) } }), p = Function.call.bind(Object.prototype.hasOwnProperty), w = (e, r = {}, n = {}) => { const g = Object.create(null), m = { has(c, s) { return s in e || s in g }, get(c, s, x) { if (s in g) return g[s]; if (!(s in e)) return; let i = e[s]; if (typeof i === 'function') if (typeof r[s] === 'function')i = R(e, e[s], r[s]); else if (p(n, s)) { const d = B(s, n[s]); i = R(e, e[s], d) } else i = i.bind(e); else if (typeof i === 'object' && i !== null && (p(r, s) || p(n, s)))i = w(i, r[s], n[s]); else if (p(n, '*'))i = w(i, r[s], n['*']); else return Object.defineProperty(g, s, { configurable: !0, enumerable: !0, get() { return e[s] }, set(d) { e[s] = d } }), i; return g[s] = i, i }, set(c, s, x, i) { return s in g ? g[s] = x : e[s] = x, !0 }, defineProperty(c, s, x) { return Reflect.defineProperty(g, s, x) }, deleteProperty(c, s) { return Reflect.deleteProperty(g, s) } }, A = Object.create(e); return new Proxy(A, m) }, C = e => ({ addListener(r, n, ...g) { r.addListener(e.get(n), ...g) }, hasListener(r, n) { return r.hasListener(e.get(n)) }, removeListener(r, n) { r.removeListener(e.get(n)) } }), W = new S(e => typeof e !== 'function' ? e : function(n) { const g = w(n, {}, { getContent: { minArgs: 0, maxArgs: 0 } }); e(g) }), N = !1, j = new S(e => typeof e !== 'function' ? e : function(n, g, m) { let A = !1, c, s = new Promise(f => { c = function(u) { N || (console.warn(o, new Error().stack), N = !0), A = !0, f(u) } }), x; try { x = e(n, g, c) } catch (f) { x = Promise.reject(f) } const i = x !== !0 && F(x); if (x !== !0 && !i && !A) return !1; const d = f => { f.then(u => { m(u) }, u => { let v; u && (u instanceof Error || typeof u.message === 'string') ? v = u.message : v = 'An unexpected error occurred', m({ __mozWebExtensionPolyfillReject__: !0, message: v }) }).catch(u => { console.error('Failed to send onMessage rejected reply', u) }) }; return d(i ? x : s), !0 }), D = ({ reject: e, resolve: r }, n) => { l.runtime.lastError ? l.runtime.lastError.message === a ? r() : e(new Error(l.runtime.lastError.message)) : n && n.__mozWebExtensionPolyfillReject__ ? e(new Error(n.message)) : r(n) }, L = (e, r, n, ...g) => { if (g.length < r.minArgs) throw new Error(`Expected at least ${r.minArgs} ${h(r.minArgs)} for ${e}(), got ${g.length}`); if (g.length > r.maxArgs) throw new Error(`Expected at most ${r.maxArgs} ${h(r.maxArgs)} for ${e}(), got ${g.length}`); return new Promise((m, A) => { const c = D.bind(null, { resolve: m, reject: A }); g.push(c), n.sendMessage(...g) }) }, I = { devtools: { network: { onRequestFinished: C(W) } }, runtime: { onMessage: C(j), onMessageExternal: C(j), sendMessage: L.bind(null, 'sendMessage', { minArgs: 1, maxArgs: 3 }) }, tabs: { sendMessage: L.bind(null, 'sendMessage', { minArgs: 2, maxArgs: 3 }) } }, E = { clear: { minArgs: 1, maxArgs: 1 }, get: { minArgs: 1, maxArgs: 1 }, set: { minArgs: 1, maxArgs: 1 } }; return k.privacy = { network: { '*': E }, services: { '*': E }, websites: { '*': E } }, w(l, I, k) }; if (typeof chrome !== 'object' || !chrome || !chrome.runtime || !chrome.runtime.id) throw new Error('This script should only be loaded in a browser extension.'); t.exports = b(chrome) } else t.exports = browser }) }); const P = K($()), y = document.createElement('script'); y.setAttribute('async', 'false'); y.setAttribute('type', 'text/javascript'); y.setAttribute('src', P.default.runtime.getURL('nostr-provider.js')); document.head.appendChild(y); self.addEventListener('message', async t => { if (t.source === self && t.data && t.data.params && t.data.ext === 'nos2bch') { let a; try { a = await P.default.runtime.sendMessage({ type: t.data.type, params: t.data.params, host: location.host }) } catch (o) { a = { error: o } }self.postMessage({ id: t.data.id, ext: 'nos2bch', response: a }, t.origin) } })
